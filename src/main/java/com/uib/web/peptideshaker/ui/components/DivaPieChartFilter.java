package com.uib.web.peptideshaker.ui.components;

import com.ejt.vaadin.sizereporter.ComponentResizeEvent;
import com.ejt.vaadin.sizereporter.SizeReporter;
import com.uib.web.peptideshaker.model.CONSTANT;
import com.uib.web.peptideshaker.model.FilterUpdatingEvent;
import com.uib.web.peptideshaker.model.Selection;
import com.uib.web.peptideshaker.ui.components.items.FilterButton;
import com.uib.web.peptideshaker.ui.abstracts.RegistrableFilter;
import com.uib.web.peptideshaker.ui.components.items.LegendItem;
import com.uib.web.peptideshaker.uimanager.SelectionManager;
import com.vaadin.event.LayoutEvents;
import com.vaadin.server.Page;
import com.vaadin.shared.ui.absolutelayout.AbsoluteLayoutState;
import com.vaadin.shared.ui.label.ContentMode;
import com.vaadin.ui.Component;
import com.vaadin.ui.Label;
import com.vaadin.ui.*;
import com.vaadin.ui.themes.ValoTheme;
import org.jfree.chart.ChartRenderingInfo;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.block.BlockBorder;
import org.jfree.chart.entity.ChartEntity;
import org.jfree.chart.entity.PieSectionEntity;
import org.jfree.chart.plot.PiePlot;
import org.jfree.data.general.DefaultPieDataset;
import org.jfree.graphics2d.svg.SVGGraphics2D;
import org.jfree.ui.RectangleEdge;
import org.jfree.ui.RectangleInsets;

import java.awt.*;
import java.util.List;
import java.util.*;

/**
 * This class represents matrix layout filter
 *
 * @author Yehia Farag
 */
public abstract class DivaPieChartFilter extends AbsoluteLayout implements RegistrableFilter {

    private final String title;
    private final String filterId;
    private final SelectionManager SelectionManager;
    private final Set<Comparable> appliedFilter;
    /**
     * The highlight selection colour (required by JFree chart).
     */
    private final Color selectedColor = Color.decode("#197de1");
    /**
     * The thumb bar-chart rendering information generated by JFree chart and
     * contain all the chart information.
     */
    private final ChartRenderingInfo mainChartRenderingInfo = new ChartRenderingInfo();
    private final LayoutEvents.LayoutClickListener dountChartListener;
    private final SizeReporter legendSizeReporter;
    /**
     * The width of the chart.
     */
    private int mainWidth;
    /**
     * The height of the chart.
     */
    private int mainHeight;
    private Label chartTitle;
    private Label mainChartImg;
    private boolean activateFilter = false;
    /**
     * The bar-chart JFree chart (required by JFree chart).
     */
    private JFreeChart chart;
    private FilterButton resetFilterBtn;
    private VerticalLayout rightLayout;
    private AbsoluteLayout mainChartContainer;
    private List<Color> standardColorList;
    private final List<Color> activeColorsList;

    public DivaPieChartFilter(String title, String filterId, SelectionManager SelectionManager) {
        this.mainWidth = -1;
        this.mainHeight = -1;
        this.title = title;
        this.filterId = filterId;
        this.SelectionManager = SelectionManager;
        this.activeColorsList = new ArrayList<>();
        this.SelectionManager.RegistrDatasetsFilter(DivaPieChartFilter.this);
        this.appliedFilter = new LinkedHashSet<>();
        this.dountChartListener = (LayoutEvents.LayoutClickEvent event) -> {
            Component clickedComponent = event.getClickedComponent();
            if (clickedComponent instanceof Label && clickedComponent.getId() != null && clickedComponent.getId().equalsIgnoreCase(this.title)) {
                ChartEntity ent = mainChartRenderingInfo.getEntityCollection().getEntity(event.getRelativeX(), event.getRelativeY());
                if (ent instanceof PieSectionEntity) {
                    applySelectedSliceFilter(((PieSectionEntity) ent).getSectionKey() + "");
                }
            }

        };
        this.initlayout();
        legendSizeReporter = new SizeReporter(rightLayout);
        legendSizeReporter.addResizeListener((ComponentResizeEvent event) -> {
            updateLegendWidth(event.getWidth());
        });

    }

    private void initlayout() {
        DivaPieChartFilter.this.setSizeFull();
        AbsoluteLayout frame = new AbsoluteLayout();
        frame.setSizeFull();
        frame.setStyleName("innerborderframe");
        frame.addStyleName("thumbfilterframe");
        frame.addStyleName("reorderlayout");
        DivaPieChartFilter.this.addComponent(frame);

        chartTitle = new Label("<font>" + title + "</font>", ContentMode.HTML);
        chartTitle.setStyleName(ValoTheme.LABEL_BOLD);
        chartTitle.setWidth(100, Unit.PIXELS);
        chartTitle.setHeight(20, Unit.PIXELS);
        chartTitle.addStyleName("resizeabletext");
        frame.addComponent(chartTitle, "left:10px; top:10px;");
        /**
         * ******************right panel*********************
         */
        rightLayout = new VerticalLayout();
        rightLayout.setWidthUndefined();
        rightLayout.setHeight(100, Unit.PERCENTAGE);
        rightLayout.addStyleName("autooverflow");
        rightLayout.addStyleName("piechartlegend");
        frame.addComponent(rightLayout, "top: 10px; right: 0px; bottom: 0px;");

        mainChartContainer = new AbsoluteLayout();
        mainChartContainer.setWidth(100, Unit.PERCENTAGE);
        mainChartContainer.setHeight(100, Unit.PERCENTAGE);
        mainChartContainer.addStyleName("divapiechartcontainerstyle");
        frame.addComponent(mainChartContainer, "left:-10px; top:20px;right:70px;bottom:5px");
        mainChartContainer.addLayoutClickListener(dountChartListener);

        mainChartImg = new Label("", ContentMode.HTML);
        mainChartImg.setVisible(true);
        mainChartImg.setId(title);
        mainChartImg.setStyleName("pointer");
        mainChartImg.addStyleName("showslow");
        mainChartImg.addStyleName("slowdrawingimg");
        mainChartImg.setHeight(100, Unit.PERCENTAGE);
        mainChartImg.setWidth(100, Unit.PERCENTAGE);
        mainChartContainer.addComponent(mainChartImg);

        JavaScript.getCurrent().addFunction("getElSizeof" + filterId,
                (arg) -> {
                    int width = (int) arg.getNumber(0);
                    int height = (int) arg.getNumber(1);
                    if (mainWidth == width && mainHeight == height) {
                        return;
                    }
                    filterSizeChanged(width, height);
                    sizeChanged(width, height);
                });

        UI.getCurrent().access(() -> {
            Page.getCurrent().addBrowserWindowResizeListener(new Page.BrowserWindowResizeListener() {
                @Override
                public void browserWindowResized(Page.BrowserWindowResizeEvent event) {
                    updateComponentSize();
                }
            });
        });

        initChart();
        resetFilterBtn = new FilterButton() {
            @Override
            public void layoutClick(LayoutEvents.LayoutClickEvent event) {
                reset();

            }
        };
        resetFilterBtn.setWidth(15, Unit.PIXELS);
        resetFilterBtn.setHeight(15, Unit.PIXELS);
        resetFilterBtn.setVisible(false);
        resetFilterBtn.addStyleName("btninframe");
        DivaPieChartFilter.this.addComponent(resetFilterBtn, "top:0px;right:0px;");
    }

    private void updateComponentSize() {
        JavaScript.getCurrent().execute(" var elem = document.getElementById('" + title + "'); "
                + " if(elem){ getElSizeof" + filterId + "(elem.clientWidth, elem.clientHeight); }");
    }

    public void sizeChanged(int tChartWidth, int tChartHeight) {
        try {

            if (tChartWidth <= 0 || tChartHeight <= 0) {
                return;
            }
            mainWidth = tChartWidth;
            mainHeight = tChartHeight;
            updateComponentSize();
            redrawChart();
            mainChartImg.setVisible(true);
        } catch (Exception ex) {
            System.out.println("at error " + this.getClass().getName() + "  " + ex);
        }

    }

    private void unselectAll(Set<Comparable> allCategories) {
        PiePlot plot = ((PiePlot) chart.getPlot());
        allCategories.stream().map((sliceKey) -> {
            plot.setSectionOutlinePaint(sliceKey, null);
            return sliceKey;
        }).forEachOrdered((sliceKey) -> {
            plot.setSectionPaint(sliceKey, activeColorsList.get(plot.getDataset().getIndex(sliceKey)));
        });

    }

    @Override
    public void redrawChart() {
        if (mainWidth < 1 || mainHeight < 1 || !activateFilter) {
            return;
        }
        String genImgUrl = saveToFile(chart, mainChartRenderingInfo, mainWidth, mainHeight);
        mainChartImg.setValue(genImgUrl);

    }

    @Override
    public String getFilterId() {
        return filterId;
    }

    @Override
    public void updateFilterSelection(Set<Comparable> selectedItems, Set<Comparable> selectedCategories, boolean topFilter, boolean singleProteinsFilter, boolean selfAction) {
    }

    /**
     * Select slice action.
     *
     * @param sliceKeys selected slice key.
     */
    private void selectSlice(Set<Comparable> sliceKeys, Set<Comparable> allCategories) {
        unselectAll(allCategories);
        if (sliceKeys != null && !sliceKeys.isEmpty()) {
            PiePlot plot = ((PiePlot) chart.getPlot());
            sliceKeys.stream().filter((sliceKey) -> !(sliceKey == null)).map((sliceKey) -> {
                plot.setSectionOutlinePaint(sliceKey, selectedColor);
                return sliceKey;
            }).map((sliceKey) -> {
                plot.setSectionPaint(sliceKey, activeColorsList.get(plot.getDataset().getIndex(sliceKey)).darker().darker());
                return sliceKey;
            }).forEachOrdered((sliceKey) -> {
                appliedFilter.add(sliceKey);
            });
        }

        redrawChart();
    }

    private void applySelectedSliceFilter(String pieSlice) {
        PiePlot plot = ((PiePlot) chart.getPlot());
        if (pieSlice != null) {
            if (plot.getSectionOutlinePaint(pieSlice) != null) {
                unSelectCategory(pieSlice);
            } else {
                selectCategory(pieSlice);
            }
        }
    }

    /**
     * Convert JFree chart into image and encode it as base64 string to be used
     * as image link.
     *
     * @param chart JFree chart instance
     * @param width Image width
     * @param height Image height.
     */
    private String saveToFile(final JFreeChart chart, ChartRenderingInfo chartRenderingInfo, int width, int height) {
        chart.getLegend().setVisible(false);
        chart.fireChartChanged();
        SVGGraphics2D g2 = new SVGGraphics2D(width, height);
        Rectangle r = new Rectangle(0, 0, width, height);
        chart.draw(g2, r, chartRenderingInfo);
        int cerWidth = (int) (chartRenderingInfo.getChartArea().getHeight() * 0.6);
        int cirR = cerWidth / 2;
        int centerx = (int) chartRenderingInfo.getChartArea().getCenterX() - cirR;
        int centery = (int) chartRenderingInfo.getChartArea().getCenterY() - cirR;
        g2.setPaint(Color.WHITE);
        g2.fillOval(centerx, centery, cerWidth, cerWidth);
        return g2.getSVGElement();
    }

    /**
     * Initialise the main JFree chart component.
     */
    private void initChart() {
        DefaultPieDataset dataset = new DefaultPieDataset();
        PiePlot plot = new PiePlot(dataset);
        plot.setNoDataMessage("No data available");
        plot.setCircular(true);
        plot.setLabelGap(0);
        plot.setBackgroundPaint(new Color(0, 0, 0, 0));
        plot.setShadowPaint(Color.WHITE);
        plot.setOutlineVisible(false);
        plot.setBaseSectionOutlinePaint(Color.WHITE);
        plot.setSectionOutlinesVisible(true);
        plot.setIgnoreZeroValues(true);
        chart = new JFreeChart(plot);
        plot.setInteriorGap(0.0);
        plot.setLabelGenerator(null);
        chart.getLegend().setItemFont(new Font("\"Open Sans\", sans-serif", Font.PLAIN, 11));
        plot.setBaseSectionOutlineStroke(new BasicStroke(2));
        plot.setInteriorGap(0);
        chart.getLegend().setPosition(RectangleEdge.RIGHT);
        chart.setPadding(new RectangleInsets(0, 0, 0, 0));
        chart.setBorderVisible(false);
        plot.setOutlinePaint(null);
        plot.setOutlineVisible(false);
        plot.setShadowYOffset(0);
        plot.setShadowXOffset(0);

        chart.setBorderPaint(null);
        chart.setBackgroundPaint(null);
        chart.getLegend().setFrame(BlockBorder.NONE);

    }

    private void updateChartDataset(Map<Comparable, Set<Integer>> datasetValuesData) {
        // column keys...    
        int counter = 0;
        // update the dataset...
        rightLayout.removeAllComponents();
        DefaultPieDataset dataset = (DefaultPieDataset) ((PiePlot) chart.getPlot()).getDataset();
        dataset.clear();

        for (Comparable key : datasetValuesData.keySet()) {
            dataset.setValue(key, scaleValues(datasetValuesData.get(key).size(), 100, 20));
            ((PiePlot) chart.getPlot()).setSectionPaint(key, this.activeColorsList.get(counter));
            if (!datasetValuesData.get(key).isEmpty()) {
                LegendItem item = new LegendItem(key + "", this.activeColorsList.get(counter));
                rightLayout.addComponent(item);
            }
            counter++;
        }

    }

    /**
     * Converts the value from linear scale to log scale. The log scale numbers
     * are limited by the range of the type float. The linear scale numbers can
     * be any double value.
     *
     * @param linearValue the value to be converted to log scale
     * @param max The upper limit number for the input numbers
     * @param lowerLimit the lower limit for the input numbers
     * @return the value in log scale
     */
    private double scaleValues(double linearValue, double max, double lowerLimit) {
        double logMax = (Math.log(max) / Math.log(2));
        double logValue = (Math.log(linearValue) / Math.log(2));
        logValue = ((max / logMax) * logValue) + lowerLimit;
        return logValue;
    }

    private void setMainAppliedFilter(boolean mainAppliedFilter) {
        resetFilterBtn.setVisible(mainAppliedFilter);
        if (mainAppliedFilter) {
            this.addStyleName("highlightfilter");
        } else {
            this.removeStyleName("highlightfilter");
        }

    }

    @Override
    public void suspendFilter(boolean suspend) {
    }

    @Override
    protected AbsoluteLayoutState getState() {
        if (super.isConnectorEnabled()) {
            updateComponentSize();
        }
        return super.getState(); //To change body of generated methods, choose Tools | Templates.
    }

    public abstract void filterSizeChanged(int w, int h);

    public abstract void updateLegendWidth(int legWidth);

    public void setLegendWidth(int width) {
        rightLayout.setWidth(width, Unit.PIXELS);
    }

    private void selectCategory(String category) {
        Set<Comparable> selectionCategories = new LinkedHashSet<>();
        selectionCategories.add(category);
        Selection selection = new Selection(CONSTANT.DATASET_SELECTION, filterId, selectionCategories, true);
        SelectionManager.setSelection(selection);
//        SelectionManager.setSelection("dataset_filter_selection", new LinkedHashSet<>(appliedFilter), null, filterId);
    }

    private void unSelectCategory(String category) {
        Set<Comparable> selectionCategories = new LinkedHashSet<>();
        selectionCategories.add(category);
        Selection selection = new Selection(CONSTANT.DATASET_SELECTION, filterId, selectionCategories, false);
        SelectionManager.setSelection(selection);
//        SelectionManager.setSelection("dataset_filter_selection", new LinkedHashSet<>(appliedFilter), null, filterId);
    }

    private void reset() {
        Selection selection = new Selection(CONSTANT.DATASET_SELECTION, filterId, null, false);
        SelectionManager.setSelection(selection);
    }

    @Override
    public void updateSelection(FilterUpdatingEvent updateEvent) {
        appliedFilter.clear();
        activateFilter = true;
        Map<Comparable, Set<Integer>> selectionMap = new LinkedHashMap<>(updateEvent.getSelectionMap());
        activeColorsList.clear();
        int index = 0;
        for (Comparable key : updateEvent.getSelectionMap().keySet()) {
            if (updateEvent.getSelectionMap().get(key).isEmpty()) {
                selectionMap.remove(key);
            } else {
                activeColorsList.add(standardColorList.get(index));
            }
            index++;
        }
        if (updateEvent.getSeletionCategories() != null && updateEvent.getSeletionCategories().containsAll(selectionMap.keySet())) {
            reset();
            return;
        }
        updateChartDataset(selectionMap);
        selectSlice(updateEvent.getSeletionCategories(), selectionMap.keySet());
        sizeChanged(mainWidth, mainHeight);
        setMainAppliedFilter(updateEvent.getSeletionCategories() != null && !updateEvent.getSeletionCategories().isEmpty());
    }

    public void setColours(Color[] standardColours) {
        this.standardColorList = new ArrayList<>(Arrays.asList(standardColours));
    }

//
}
