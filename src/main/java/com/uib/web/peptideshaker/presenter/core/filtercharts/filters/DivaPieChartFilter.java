package com.uib.web.peptideshaker.presenter.core.filtercharts.filters;

import com.ejt.vaadin.sizereporter.ComponentResizeEvent;
import com.ejt.vaadin.sizereporter.ComponentResizeListener;
import com.ejt.vaadin.sizereporter.SizeReporter;
import com.google.common.collect.Sets;
import com.uib.web.peptideshaker.presenter.core.FilterButton;
import com.uib.web.peptideshaker.presenter.core.filtercharts.RegistrableFilter;
import com.uib.web.peptideshaker.presenter.core.filtercharts.components.LegendItem;
import com.uib.web.peptideshaker.presenter.layouts.peptideshakerview.SelectionManager;
import com.vaadin.event.LayoutEvents;
import com.vaadin.server.Page;
import com.vaadin.shared.ui.absolutelayout.AbsoluteLayoutState;
import com.vaadin.shared.ui.label.ContentMode;
import com.vaadin.ui.Component;
import com.vaadin.ui.Label;
import com.vaadin.ui.*;
import com.vaadin.ui.themes.ValoTheme;
import org.jfree.chart.ChartRenderingInfo;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.block.BlockBorder;
import org.jfree.chart.entity.ChartEntity;
import org.jfree.chart.entity.PieSectionEntity;
import org.jfree.chart.plot.PiePlot;
import org.jfree.data.general.DefaultPieDataset;
import org.jfree.graphics2d.svg.SVGGraphics2D;
import org.jfree.ui.RectangleEdge;
import org.jfree.ui.RectangleInsets;

import java.awt.*;
import java.util.List;
import java.util.*;

/**
 * This class represents matrix layout filter
 *
 * @author Yehia Farag
 */
public abstract class DivaPieChartFilter extends AbsoluteLayout implements RegistrableFilter {

    private final String title;
    private final String filterId;
    private final Set<Comparable> fullItemsSet;
    private final SelectionManager Selection_Manager;
    private final Set<Comparable> appliedFilter;
    /**
     * The highlight selection color (required by JFree chart).
     */
    private final Color selectedColor = Color.decode("#197de1");
    /**
     * The thumb bar-chart rendering information generated by JFree chart and
     * contain all the chart information.
     */
    private final ChartRenderingInfo mainChartRenderingInfo = new ChartRenderingInfo();
    private final LayoutEvents.LayoutClickListener dountChartListener;
    private final SizeReporter legendSizeReporter;
    /**
     * The width of the chart.
     */
    private int mainWidth;
    /**
     * A wite layout that has the label and turn pie-chart into donut chart.
     */
//    private VerticalLayout middleDountLayout;
    /**
     * The chart label contain the total number of datasets.
     */
//    private Label selectAllLabel;
    /**
     * The height of the chart.
     */
    private int mainHeight;
    private Label chartTitle;
    private Label mainChartImg;
    private boolean activateFilter = false;
    /**
     * The bar-chart JFree chart (required by JFree chart).
     */
    private JFreeChart chart;
//    private int imageRepaintCounter;
    private FilterButton resetFilterBtn;
    private VerticalLayout rightLayout;
    private AbsoluteLayout mainChartContainer;
    private Map<String, Set<Comparable>> fullData;
    private List<Color> colorsList;

    public DivaPieChartFilter(String title, String filterId, SelectionManager Selection_Manager) {
        this.mainWidth = -1;
        this.mainHeight = -1;
        this.title = title;
        this.filterId = filterId;
        this.Selection_Manager = Selection_Manager;
        this.Selection_Manager.RegistrDatasetsFilter(DivaPieChartFilter.this);
        this.fullItemsSet = new LinkedHashSet<>();
        this.appliedFilter = new LinkedHashSet<>();
        this.dountChartListener = (LayoutEvents.LayoutClickEvent event) -> {
            Component clickedComponent = event.getClickedComponent();
            if (clickedComponent instanceof Label && clickedComponent.getId() != null && clickedComponent.getId().equalsIgnoreCase(this.title)) {

                ChartEntity ent = mainChartRenderingInfo.getEntityCollection().getEntity(event.getRelativeX(), event.getRelativeY());
                if (ent instanceof PieSectionEntity) {
                    applyFilter(((PieSectionEntity) ent).getSectionKey() + "");
                }
            } else {
                applyFilter(null);
            }
        };
        this.initlayout();
        legendSizeReporter = new SizeReporter(rightLayout);
        legendSizeReporter.addResizeListener(new ComponentResizeListener() {
            @Override
            public void sizeChanged(ComponentResizeEvent event) {
                updateLegendWidth(event.getWidth());
            }
        });

    }

    private void initlayout() {
        DivaPieChartFilter.this.setSizeFull();
        AbsoluteLayout frame = new AbsoluteLayout();
        frame.setSizeFull();
        frame.setStyleName("innerborderframe");
        frame.addStyleName("thumbfilterframe");
        frame.addStyleName("reorderlayout");
        DivaPieChartFilter.this.addComponent(frame);

        chartTitle = new Label("<font>" + title + "</font>", ContentMode.HTML);
        chartTitle.setStyleName(ValoTheme.LABEL_BOLD);
        chartTitle.setWidth(100, Unit.PIXELS);
        chartTitle.setHeight(20, Unit.PIXELS);
        chartTitle.addStyleName("resizeabletext");
        frame.addComponent(chartTitle, "left:10px; top:10px;");
        /**
         * ******************right panel*********************
         */
        rightLayout = new VerticalLayout();
        rightLayout.setWidthUndefined();
        rightLayout.setHeight(100, Unit.PERCENTAGE);
        rightLayout.addStyleName("autooverflow");
        rightLayout.addStyleName("piechartlegend");
        frame.addComponent(rightLayout, "top: 10px; right: 0px; bottom: 0px;");

        mainChartContainer = new AbsoluteLayout();
        mainChartContainer.setWidth(100, Unit.PERCENTAGE);
        mainChartContainer.setHeight(100, Unit.PERCENTAGE);
        mainChartContainer.addStyleName("divapiechartcontainerstyle");
        frame.addComponent(mainChartContainer, "left:-10px; top:20px;right:70px;bottom:5px");
        mainChartContainer.addLayoutClickListener(dountChartListener);

//        middleDountLayout = new VerticalLayout();
//        middleDountLayout.setSizeFull();
//        middleDountLayout.setVisible(false);
////        mainChartContainer.addComponent(middleDountLayout, "left:0px; top:0px;");
//        selectAllLabel = new Label();//"<center>1000000</center>", ContentMode.HTML);
//        selectAllLabel.addStyleName("middledountchart");
//        selectAllLabel.addStyleName(ValoTheme.LABEL_TINY);
//        selectAllLabel.addStyleName(ValoTheme.LABEL_SMALL);
//        selectAllLabel.setReadOnly(true);
//        
//        middleDountLayout.addComponent(selectAllLabel);
//        middleDountLayout.setComponentAlignment(selectAllLabel, Alignment.MIDDLE_CENTER);
        mainChartImg = new Label("", ContentMode.HTML);
        mainChartImg.setVisible(true);
        mainChartImg.setId(title);
        mainChartImg.setStyleName("pointer");
        mainChartImg.addStyleName("showslow");
        mainChartImg.addStyleName("slowdrawingimg");
        mainChartImg.setHeight(100, Unit.PERCENTAGE);
        mainChartImg.setWidth(100, Unit.PERCENTAGE);
        mainChartContainer.addComponent(mainChartImg);

        JavaScript.getCurrent().addFunction("getElSizeof" + filterId,
                (arg) -> {
                    int width = (int) arg.getNumber(0);
                    int height = (int) arg.getNumber(1);
                    if (mainWidth == width && mainHeight == height) {
                        return;
                    }
                    filterSizeChanged(width, height);
                    sizeChanged(width, height);
                });

        UI.getCurrent().access(() -> {
            Page.getCurrent().addBrowserWindowResizeListener(new Page.BrowserWindowResizeListener() {
                @Override
                public void browserWindowResized(Page.BrowserWindowResizeEvent event) {
                    updateComponentSize();
                }
            });
        });

        initChart();
        resetFilterBtn = new FilterButton() {
            @Override
            public void layoutClick(LayoutEvents.LayoutClickEvent event) {
                appliedFilter.clear();
                applyFilter(null);

            }
        };
        resetFilterBtn.setWidth(15, Unit.PIXELS);
        resetFilterBtn.setHeight(15, Unit.PIXELS);
        resetFilterBtn.setVisible(false);
        resetFilterBtn.addStyleName("btninframe");
        DivaPieChartFilter.this.addComponent(resetFilterBtn, "top:0px;right:0px;");
    }

    private void updateComponentSize() {
        JavaScript.getCurrent().execute(" var elem = document.getElementById('" + title + "'); "
                + " if(elem){ getElSizeof" + filterId + "(elem.clientWidth, elem.clientHeight); }");
    }

    public void sizeChanged(int tChartWidth, int tChartHeight) {
        try {

            if (tChartWidth <= 0 || tChartHeight <= 0) {
                return;
            }
            mainWidth = tChartWidth;
            mainHeight = tChartHeight;
            updateComponentSize();
            redrawChart();
//            middleDountLayout.setVisible(true);
            mainChartImg.setVisible(true);
        } catch (Exception ex) {
            System.out.println("at error " + this.getClass().getName() + "  " + ex);
        }

    }

    public void initializeFilterData(Map<String, Set<Comparable>> fullData, List<Color> colorsArr) {
        activateFilter = true;
        Map<String, Set<Comparable>> filterfullData = new LinkedHashMap<>(fullData);
        colorsList = new ArrayList<>(colorsArr);
        int index = 0;
        filterfullData.keySet().stream().filter((key) -> (fullData.get(key).isEmpty())).map((key) -> {
            fullData.remove(key);
            return key;
        }).forEachOrdered((_item) -> {
            colorsList.remove(index);
        });
        this.fullData = fullData;
        fullItemsSet.clear();
        fullData.keySet().forEach((key) -> {
            fullItemsSet.addAll(fullData.get(key));
        });
        updateChartDataset(fullData);
        sizeChanged(mainWidth, mainHeight);

    }

    public void initializeFilterData(Map<String, Set<Comparable>> fullData, Map<String, Color> colorMap) {
        activateFilter = true;
        Map<String, Set<Comparable>> filterfullData = new LinkedHashMap<>(fullData);
        colorsList = new ArrayList<>();
        filterfullData.keySet().stream().filter((key) -> (fullData.get(key).isEmpty())).map((key) -> {
            fullData.remove(key);
            return key;
        }).forEachOrdered((_item) -> {
        });
        this.fullData = fullData;
        fullItemsSet.clear();
        fullData.keySet().forEach((key) -> {
            colorsList.add(colorMap.get(key.replace("Protein", "").trim()));
            fullItemsSet.addAll(fullData.get(key));
        });
        updateChartDataset(fullData);
        sizeChanged(mainWidth, mainHeight);

    }

    //    private void reDrawLayout() {
//        //calc 60% of width
//        double w = Math.min(mainWidth, mainHeight);
//        w = 60 * w / 100.0;
//        selectAllLabel.setWidth((float) w, Unit.PIXELS);
//        selectAllLabel.setHeight((float) w, Unit.PIXELS);
//    }
    private void unselectAll() {
        PiePlot plot = ((PiePlot) chart.getPlot());
        fullData.keySet().stream().map((sliceKey) -> {
            plot.setSectionOutlinePaint(sliceKey, null);
            return sliceKey;
        }).forEachOrdered((sliceKey) -> {
            plot.setSectionPaint(sliceKey, colorsList.get(plot.getDataset().getIndex(sliceKey)));
        });

    }

    @Override
    public void redrawChart() {
        if (mainWidth < 1 || mainHeight < 1 || !activateFilter) {
            return;
        }
//        reDrawLayout();
        String genImgUrl = saveToFile(chart, mainChartRenderingInfo, mainWidth, mainHeight);
        mainChartImg.setValue(genImgUrl);

    }

    @Override
    public String getFilterId() {
        return filterId;
    }

    @Override
    public void updateFilterSelection(Set<Comparable> selectedItems, Set<Comparable> selectedCategories, boolean topFilter, boolean singleProteinsFilter, boolean selfAction) {
        if (!selfAction) {
            if (singleProteinsFilter && !selfAction && !selectedCategories.isEmpty()) {
                //reset filter value to oreginal 
                initializeFilterData(fullData, colorsList);
            } else {
                Map<String, Set<Comparable>> tPieChartValues = new LinkedHashMap<>();
                fullData.keySet().forEach((key) -> {
                    tPieChartValues.put(key, new LinkedHashSet<>(Sets.intersection(fullData.get(key), selectedItems)));
                });
                updateChartDataset(tPieChartValues);
            }
            redrawChart();
        }
        selectSlice(selectedCategories);
        setMainAppliedFilter(topFilter && !selectedCategories.isEmpty());
    }

    /**
     * Select slice action.
     *
     * @param sliceKey selected slice key.
     */
    private void selectSlice(Set<Comparable> sliceKeys) {
        unselectAll();
        if (!sliceKeys.isEmpty()) {
            PiePlot plot = ((PiePlot) chart.getPlot());
            sliceKeys.stream().filter((sliceKey) -> !(sliceKey == null)).map((sliceKey) -> {
                plot.setSectionOutlinePaint(sliceKey, selectedColor);
                return sliceKey;
            }).map((sliceKey) -> {
                plot.setSectionPaint(sliceKey, colorsList.get(plot.getDataset().getIndex(sliceKey)).darker().darker());
                return sliceKey;
            }).forEachOrdered((sliceKey) -> {
                appliedFilter.add(sliceKey);
            });
        }

        redrawChart();
    }

    private void applyFilter(String pieSlice) {
        if ((appliedFilter.size() >= rightLayout.getComponentCount() && (rightLayout.getComponentCount() != fullData.size())) || rightLayout.getComponentCount() == 1) {
            return;
        }
        PiePlot plot = ((PiePlot) chart.getPlot());
        if (pieSlice != null) {

            if (plot.getSectionOutlinePaint(pieSlice) != null) {
                appliedFilter.remove(pieSlice);
            } else {
                appliedFilter.add(pieSlice);
                if (appliedFilter.size() == rightLayout.getComponentCount()) {
                    appliedFilter.clear();
                    applyFilter(null);
                }
            }
        }

        Selection_Manager.setSelection("dataset_filter_selection", new LinkedHashSet<>(appliedFilter), null, filterId);
    }

    /**
     * Convert JFree chart into image and encode it as base64 string to be used
     * as image link.
     *
     * @param chart  JFree chart instance
     * @param width  Image width
     * @param height Image height.
     */
    private String saveToFile(final JFreeChart chart, ChartRenderingInfo chartRenderingInfo, int width, int height) {
        chart.getLegend().setVisible(false);
        chart.fireChartChanged();
        SVGGraphics2D g2 = new SVGGraphics2D(width, height);
        Rectangle r = new Rectangle(0, 0, width, height);
        chart.draw(g2, r, chartRenderingInfo);
        int cerWidth = (int) (chartRenderingInfo.getChartArea().getHeight() * 0.6);
        int cirR = cerWidth / 2;
        int centerx = (int) chartRenderingInfo.getChartArea().getCenterX() - cirR;
        int centery = (int) chartRenderingInfo.getChartArea().getCenterY() - cirR;
        g2.setPaint(Color.WHITE);
        g2.fillOval(centerx, centery, cerWidth, cerWidth);
        return g2.getSVGElement();
    }

    /**
     * Initialise the main JFree chart component.
     */
    private void initChart() {
        DefaultPieDataset dataset = new DefaultPieDataset();

        PiePlot plot = new PiePlot(dataset);
        plot.setNoDataMessage("No data available");
        plot.setCircular(true);
        plot.setLabelGap(0);
        plot.setBackgroundPaint(new Color(0, 0, 0, 0));
        plot.setShadowPaint(Color.WHITE);
        plot.setOutlineVisible(false);
        plot.setBaseSectionOutlinePaint(Color.WHITE);
        plot.setSectionOutlinesVisible(true);
        plot.setIgnoreZeroValues(true);
        chart = new JFreeChart(plot);
        plot.setInteriorGap(0.0);
        plot.setLabelGenerator(null);
        chart.getLegend().setItemFont(new Font("\"Open Sans\", sans-serif", Font.PLAIN, 11));
        plot.setBaseSectionOutlineStroke(new BasicStroke(2));
        plot.setInteriorGap(0);
        chart.getLegend().setPosition(RectangleEdge.RIGHT);
        chart.setPadding(new RectangleInsets(0, 0, 0, 0));
        chart.setBorderVisible(false);
        plot.setOutlinePaint(null);
        plot.setOutlineVisible(false);
        plot.setShadowYOffset(0);
        plot.setShadowXOffset(0);

        chart.setBorderPaint(null);
        chart.setBackgroundPaint(null);
        chart.getLegend().setFrame(BlockBorder.NONE);

    }

    private void updateChartDataset(Map<String, Set<Comparable>> datasetValuesData) {
        // column keys...    
        int counter = 0;
        // update the dataset...
        rightLayout.removeAllComponents();
        DefaultPieDataset dataset = (DefaultPieDataset) ((PiePlot) chart.getPlot()).getDataset();
        dataset.clear();

        for (String key : datasetValuesData.keySet()) {
            dataset.setValue(key, scaleValues(datasetValuesData.get(key).size(), 100, 20));
            ((PiePlot) chart.getPlot()).setSectionPaint(key, this.colorsList.get(counter));
            if (!datasetValuesData.get(key).isEmpty()) {
                LegendItem item = new LegendItem(key + "", this.colorsList.get(counter));
                rightLayout.addComponent(item);
            }
            counter++;
        }

    }

    /**
     * Converts the value from linear scale to log scale. The log scale numbers
     * are limited by the range of the type float. The linear scale numbers can
     * be any double value.
     *
     * @param linearValue the value to be converted to log scale
     * @param max         The upper limit number for the input numbers
     * @param lowerLimit  the lower limit for the input numbers
     * @return the value in log scale
     */
    private double scaleValues(double linearValue, double max, double lowerLimit) {
        double logMax = (Math.log(max) / Math.log(2));
        double logValue = (Math.log(linearValue) / Math.log(2));
        logValue = ((max / logMax) * logValue) + lowerLimit;
        return logValue;
    }

    private void setMainAppliedFilter(boolean mainAppliedFilter) {
        resetFilterBtn.setVisible(mainAppliedFilter);
        if (mainAppliedFilter) {
            this.addStyleName("highlightfilter");
        } else {
            this.removeStyleName("highlightfilter");
        }

    }

    @Override
    public void suspendFilter(boolean suspend) {
    }

    @Override
    protected AbsoluteLayoutState getState() {
        if (super.isConnectorEnabled()) {
            updateComponentSize();
        }
        return super.getState(); //To change body of generated methods, choose Tools | Templates.
    }

    public abstract void filterSizeChanged(int w, int h);

    public abstract void updateLegendWidth(int legWidth);

    public void setLegendWidth(int width) {
        rightLayout.setWidth(width, Unit.PIXELS);
    }

//
}
